---
description: "Context Engineering增强的功能开发实施计划模板"
scripts:
  sh: scripts/bash/update-agent-context.sh __AGENT__
  ps: scripts/powershell/update-agent-context.ps1 -AgentType __AGENT__
---

# 实施计划：[功能] - Context Engineering Enhanced

**分支**: `[###-功能名称]` | **日期**: [日期] | **规范**: [链接]
**输入**: 来自 `/specs/[###-功能名称]/spec.md` 的功能规范
**上下文工程模式**: [轻量级/标准/深度/ULTRATHINK]

## 执行流程（Context Engineering Enhanced /plan 命令）
```
1. 上下文加载和分析阶段
   → 从输入路径加载功能规范
   → 如果未找到：错误 "在 {路径} 处未找到功能规范"
   → 分析规范中的上下文工程级别
   → 初始化对应级别的分析深度

2. 智能技术上下文构建
   → 扫描 NEEDS CLARIFICATION 并基于代码库上下文推理
   → 自动检测项目类型和技术栈
   → 分析现有架构模式和约束
   → 识别技术债务和优化机会
   → 基于项目类型设置结构决策

3. 深度代码库分析
   → 搜索相似功能实现模式
   → 分析现有数据模型和API设计
   → 识别可复用的组件和工具
   → 评估现有测试覆盖率和模式
   → 分析性能基准和瓶颈

4. 增强宪法检查
   → 基于宪法文档内容填写宪法检查部分
   → 结合代码库历史和最佳实践
   → 评估技术决策的长期影响
   → 如果存在违规：在复杂性跟踪中记录并提供解决方案
   → 如果无法证明合理性：错误 "首先简化方法" + 具体建议
   → 更新进度跟踪：增强宪法检查

5. 上下文驱动研究阶段 → research.md
   → 基于功能复杂度执行对应深度的研究
   → 自动收集相关技术文档和最佳实践
   → 分析类似项目的实现方案
   → 识别潜在的技术风险和缓解策略
   → 如果仍有 NEEDS CLARIFICATION：提供基于上下文的建议解决方案

6. 智能设计生成阶段 → 合约、data-model.md、quickstart.md、代理特定模板文件
   → 基于现有模式生成一致的设计
   → 自动生成API合约（如果适用）
   → 创建与现有数据模型兼容的设计
   → 生成基于现有测试模式的快速开始指南
   → 创建针对特定AI代理的优化指令

7. 验证驱动的设计审查
   → 重新评估宪法检查部分
   → 执行自动化设计一致性检查
   → 验证与现有架构的兼容性
   → 如果有新违规：提供具体的重构建议，返回阶段6
   → 更新进度跟踪：验证驱动设计审查

8. 上下文丰富的任务规划 → 描述任务生成方法
   → 基于代码库复杂度估算任务粒度
   → 识别关键路径和并行执行机会
   → 生成基于现有模式的任务模板
   → 预定义验证检查点和回滚策略

9. 准备执行 /tasks 命令
   → 生成上下文丰富的任务生成指令
   → 准备验证工具和检查清单
   → 设置持续集成和反馈循环
```

**重要**: Context Engineering增强的/plan命令在步骤8停止，但提供更丰富的上下文给后续阶段：
- 阶段2：/tasks 命令创建上下文感知的 tasks.md
- 阶段3-4：实施执行（手动或通过工具，带有验证循环）

## 摘要 - Context Enhanced
[从功能规范中提取：主要需求 + 来自研究的技术方法 + 与现有系统的集成点]

**上下文洞察**: [基于代码库分析的关键洞察]
**实施策略**: [基于现有模式的推荐方法]
**风险评估**: [识别的技术风险和缓解策略]

## 技术上下文 - Context Engineering Enhanced
**语言/版本**: [基于代码库自动检测，例如，Python 3.11、Swift 5.9、Rust 1.75]
**主要依赖**: [基于现有依赖分析，例如，FastAPI、UIKit、LLVM]
**存储**: [基于现有数据层分析，例如，PostgreSQL、CoreData、文件]
**测试**: [基于现有测试框架，例如，pytest、XCTest、cargo test]
**目标平台**: [基于现有部署配置，例如，Linux服务器、iOS 15+、WASM]
**项目类型**: [自动检测：单一/web/移动 - 决定源结构]
**性能目标**: [基于现有性能基准，例如，1000 req/s、10k lines/sec、60 fps]
**约束**: [基于现有架构约束，例如，<200ms p95、<100MB内存、离线能力]
**规模/范围**: [基于项目历史数据，例如，10k用户、1M LOC、50个屏幕]

### 上下文分析结果
```yaml
现有模式分析:
  - 相似功能: [识别的相似功能列表]
  - 可复用组件: [可以复用的现有组件]
  - 架构模式: [项目使用的架构模式]
  - 数据流模式: [现有的数据处理模式]

技术债务评估:
  - 当前债务: [识别的技术债务]
  - 影响评估: [对新功能的影响]
  - 优化机会: [可以同时解决的优化点]

集成复杂度:
  - 集成点数量: [需要集成的系统数量]
  - 数据一致性: [数据一致性要求]
  - API兼容性: [API版本兼容性考虑]
```

## 宪法检查 - Context Engineering Enhanced
*门控：必须在阶段0研究前通过。在阶段1设计后重新检查。*

[基于宪法文件确定的门控 + 上下文特定的检查项]

### 增强检查项
- **架构一致性**: 新功能是否符合现有架构模式
- **性能影响**: 是否会对现有性能产生负面影响
- **安全合规**: 是否遵循现有安全标准和实践
- **可维护性**: 是否增加了不必要的复杂性
- **测试覆盖**: 是否有充分的测试策略

## 项目结构 - Context Enhanced

### 文档（此功能）
```
specs/[###-功能]/
├── plan.md              # 此文件（Context Enhanced /plan 命令输出）
├── research.md          # 阶段0输出（深度研究结果）
├── data-model.md        # 阶段1输出（与现有模型兼容的设计）
├── quickstart.md        # 阶段1输出（基于现有模式的快速开始）
├── contracts/           # 阶段1输出（API合约设计）
├── context-analysis.md  # Context Engineering特有：上下文分析结果
├── validation-plan.md   # Context Engineering特有：验证策略
└── tasks.md             # 阶段2输出（/tasks 命令 - 不由 /plan 创建）
```

### 源代码（仓库根目录）- Context Aware
<!--
  需要操作：基于现有代码库结构和模式，用此功能的具体布局替换下面的占位符树。
  删除未使用的选项并用真实路径扩展所选结构。交付的计划不得包含选项标签。
  Context Engineering增强：自动分析现有结构并建议最佳集成点。
-->
```
# 基于现有架构模式的推荐结构
src/
├── [基于现有模式的模块结构]
├── [新功能模块，遵循现有命名约定]
└── [集成点，最小化对现有代码的影响]

tests/
├── [遵循现有测试结构]
└── [新功能测试，使用现有测试工具]

docs/
├── [更新现有文档]
└── [新功能文档，符合现有文档风格]
```

## 实施蓝图 - Context Engineering Core

### 阶段0：深度研究和上下文收集
```yaml
研究目标:
  - 技术可行性验证
  - 最佳实践收集
  - 风险识别和缓解
  - 性能基准建立

上下文收集:
  - 代码库模式分析
  - 依赖关系映射
  - 测试覆盖率评估
  - 文档完整性检查

输出文档:
  - research.md: 技术研究结果
  - context-analysis.md: 代码库上下文分析
```

### 阶段1：上下文驱动设计
```yaml
设计原则:
  - 遵循现有架构模式
  - 最小化集成复杂度
  - 保持向后兼容性
  - 优化可测试性

设计工件:
  - data-model.md: 数据模型设计（与现有模型兼容）
  - contracts/: API合约（遵循现有API设计）
  - quickstart.md: 快速开始指南（基于现有模式）
  - validation-plan.md: 验证策略

质量门控:
  - 架构一致性检查
  - 性能影响评估
  - 安全合规验证
```

### 阶段2：智能任务生成准备
```yaml
任务生成策略:
  - 基于现有开发模式
  - 考虑团队技能和经验
  - 优化并行执行机会
  - 内置验证检查点

任务分类:
  - 设置任务：环境和依赖
  - 核心任务：主要功能实现
  - 集成任务：与现有系统集成
  - 验证任务：测试和质量保证
  - 完善任务：文档和优化

依赖管理:
  - 自动识别任务依赖
  - 生成并行执行计划
  - 设置关键路径监控
```

## 验证策略 - Context Engineering Enhanced

### 多层验证体系
```yaml
静态验证:
  - 代码风格检查: [基于现有linting配置]
  - 类型检查: [使用项目现有的类型检查工具]
  - 安全扫描: [集成现有安全工具]

动态验证:
  - 单元测试: [遵循现有测试模式]
  - 集成测试: [基于现有集成测试框架]
  - 端到端测试: [使用现有E2E测试工具]

性能验证:
  - 基准测试: [基于现有性能基准]
  - 负载测试: [使用现有负载测试工具]
  - 内存分析: [集成现有分析工具]

持续验证:
  - CI/CD集成: [基于现有CI/CD流水线]
  - 自动化回归测试: [扩展现有回归测试套件]
  - 监控和告警: [集成现有监控系统]
```

### 验证检查点
```yaml
开发阶段检查点:
  - 设计审查: 架构和设计一致性
  - 代码审查: 代码质量和最佳实践
  - 测试审查: 测试覆盖率和质量
  - 集成审查: 系统集成和兼容性
  - 发布审查: 生产就绪性评估

自动化门控:
  - 构建成功: 所有组件成功构建
  - 测试通过: 所有测试用例通过
  - 覆盖率达标: 测试覆盖率满足要求
  - 性能达标: 性能指标满足要求
  - 安全合规: 安全扫描无高危问题
```

## 风险管理 - Context Engineering Enhanced

### 风险识别和评估
```yaml
技术风险:
  - 新技术学习曲线: [评估和缓解策略]
  - 集成复杂度: [复杂度评估和简化方案]
  - 性能影响: [性能风险和优化策略]
  - 安全漏洞: [安全风险和防护措施]

项目风险:
  - 时间估算偏差: [基于历史数据的调整]
  - 资源可用性: [资源规划和备选方案]
  - 需求变更: [变更管理和影响评估]
  - 质量标准: [质量保证和验收标准]

运营风险:
  - 部署复杂度: [部署策略和回滚计划]
  - 监控盲点: [监控覆盖和告警策略]
  - 维护负担: [维护策略和文档]
  - 用户接受度: [用户培训和支持]
```

### 缓解策略
```yaml
预防措施:
  - 原型验证: 关键技术的早期验证
  - 增量开发: 分阶段交付和验证
  - 持续集成: 早期发现和解决问题
  - 代码审查: 多人审查确保质量

应急计划:
  - 回滚策略: 快速回滚到稳定版本
  - 降级方案: 功能降级保持核心服务
  - 热修复: 快速修复关键问题
  - 沟通计划: 及时沟通和状态更新
```

## 成功指标 - Context Engineering Enhanced

### 技术指标
```yaml
代码质量:
  - 代码覆盖率: [目标覆盖率基于现有标准]
  - 代码复杂度: [复杂度指标和阈值]
  - 技术债务: [债务指标和改进目标]

性能指标:
  - 响应时间: [基于现有性能基准]
  - 吞吐量: [基于业务需求和现有能力]
  - 资源使用: [CPU、内存、存储使用目标]

可靠性指标:
  - 可用性: [可用性目标和SLA]
  - 错误率: [错误率阈值和监控]
  - 恢复时间: [故障恢复时间目标]
```

### 业务指标
```yaml
用户体验:
  - 用户满意度: [满意度调查和反馈]
  - 功能采用率: [功能使用率和趋势]
  - 用户留存: [用户留存率和流失分析]

业务价值:
  - 业务目标达成: [具体业务指标]
  - 成本效益: [开发成本和业务收益]
  - 市场竞争力: [竞争优势和差异化]
```

---

*此实施计划使用Context Engineering深度增强，提供全面的上下文分析、智能设计生成和多层验证策略，确保高质量的功能实施。*