---
description: "Context Engineering增强的任务生成模板"
scripts:
  sh: scripts/bash/update-agent-context.sh __AGENT__
  ps: scripts/powershell/update-agent-context.ps1 -AgentType __AGENT__
---

# 任务列表：[功能] - Context Engineering Enhanced

**分支**: `[###-功能名称]` | **日期**: [日期] | **规范**: [链接]
**输入**: 来自 `/specs/[###-功能名称]/` 的设计工件
**上下文工程模式**: [轻量级/标准/深度/ULTRATHINK]
**任务生成策略**: [基于现有模式/创新实现/混合方法]

## 执行流程（Context Engineering Enhanced /tasks 命令）
```
1. 上下文加载和分析
   → 从功能目录加载所有可用文档
   → 分析 plan.md、data-model.md、contracts/、research.md、quickstart.md
   → 加载 context-analysis.md 和 validation-plan.md（如果存在）
   → 评估项目复杂度和现有开发模式

2. 智能任务分析
   → 基于现有代码库模式识别任务类型
   → 分析功能复杂度和技术栈要求
   → 识别关键路径和并行执行机会
   → 评估团队技能和历史开发速度

3. 上下文驱动任务生成
   → 使用 context-enhanced-tasks-template.md
   → 基于现有项目结构生成具体任务
   → 集成验证检查点和质量门控
   → 生成依赖关系图和执行计划

4. 智能依赖排序
   → 分析任务间的技术依赖关系
   → 识别可并行执行的任务组
   → 优化关键路径和资源利用
   → 生成风险缓解和回滚策略

5. 验证和优化
   → 验证任务完整性和可执行性
   → 检查与现有开发流程的兼容性
   → 优化任务粒度和执行顺序
   → 生成进度跟踪和监控指标

6. 输出生成
   → 创建包含编号任务的 tasks.md
   → 包含文件路径、依赖说明和验证标准
   → 生成并行执行示例和最佳实践
   → 提供上下文丰富的实施指导
```

## 任务生成规则 - Context Engineering Enhanced

### 基于现有模式的任务识别
```yaml
代码库分析驱动:
  - 扫描现有相似功能的实现模式
  - 识别可复用的组件和工具
  - 分析现有测试策略和覆盖率
  - 评估现有文档和注释质量

技术栈特定规则:
  - 基于项目使用的框架和库
  - 遵循现有的架构模式和约定
  - 集成现有的构建和部署流程
  - 利用现有的开发工具和环境

质量标准集成:
  - 基于现有的代码质量标准
  - 集成现有的测试和验证流程
  - 遵循现有的安全和合规要求
  - 维护现有的性能和可靠性标准
```

### 智能任务分类系统
```yaml
设置任务 (Setup):
  条件: 需要新的依赖、环境配置或工具
  模式: 基于现有的环境配置模式
  验证: 环境就绪性检查和依赖验证

核心任务 (Core):
  条件: 主要功能实现和业务逻辑
  模式: 遵循现有的代码组织和设计模式
  验证: 功能完整性和业务逻辑验证

集成任务 (Integration):
  条件: 与现有系统的集成点
  模式: 基于现有的集成模式和API设计
  验证: 集成测试和兼容性验证

测试任务 (Testing):
  条件: 测试用例开发和验证
  模式: 遵循现有的测试框架和策略
  验证: 测试覆盖率和质量验证

完善任务 (Polish):
  条件: 文档、优化和用户体验改进
  模式: 基于现有的文档和UX标准
  验证: 用户接受度和质量标准验证
```

## 任务模板 - Context Engineering Enhanced

### 设置任务模板
```markdown
## 设置任务

### S1: 环境和依赖准备
**描述**: [基于现有环境配置模式的具体描述]
**文件**: [具体的配置文件路径，基于现有项目结构]
**依赖**: 无
**验证标准**: 
- [ ] 所有依赖成功安装
- [ ] 环境配置验证通过
- [ ] 与现有环境兼容性确认
**上下文**: [相关的现有配置和最佳实践]
**风险缓解**: [基于历史问题的预防措施]

### S2: 开发工具配置
**描述**: [基于现有开发工具链的配置]
**文件**: [工具配置文件，遵循现有约定]
**依赖**: S1
**验证标准**:
- [ ] 开发工具正常工作
- [ ] 与现有工具链集成
- [ ] 代码质量检查配置
**上下文**: [现有工具配置和团队偏好]
**最佳实践**: [基于团队经验的建议]
```

### 核心任务模板
```markdown
## 核心实现任务

### C1: [核心功能模块]
**描述**: [基于设计文档的具体实现描述]
**文件**: [具体文件路径，遵循现有代码组织]
**依赖**: [设置任务和相关核心任务]
**验证标准**:
- [ ] 功能按规范实现
- [ ] 代码质量符合标准
- [ ] 单元测试覆盖率达标
- [ ] 性能指标满足要求
**上下文**: 
- 相关现有代码: [链接到相似实现]
- 设计模式: [使用的设计模式和原因]
- 技术约束: [需要考虑的技术限制]
**实施指导**:
- 遵循现有的[具体模式名称]模式
- 复用[具体组件名称]组件
- 参考[具体文件路径]的实现方式
**质量门控**:
- 代码审查检查清单
- 自动化测试验证
- 性能基准测试
```

### 集成任务模板
```markdown
## 集成任务

### I1: [系统集成点]
**描述**: [与现有系统的具体集成描述]
**文件**: [集成相关的文件路径]
**依赖**: [相关核心任务]
**验证标准**:
- [ ] 集成接口正常工作
- [ ] 数据流验证通过
- [ ] 向后兼容性确认
- [ ] 集成测试通过
**上下文**:
- 现有集成模式: [描述现有的集成方法]
- API兼容性: [版本兼容性要求]
- 数据格式: [数据交换格式和约定]
**集成策略**:
- 渐进式集成方法
- 回滚和降级策略
- 监控和告警配置
**风险管理**:
- 集成失败的应急方案
- 数据一致性保证措施
- 性能影响评估和优化
```

### 测试任务模板
```markdown
## 测试和验证任务

### T1: [测试类型]
**描述**: [基于现有测试策略的具体测试描述]
**文件**: [测试文件路径，遵循现有测试结构]
**依赖**: [相关实现任务]
**验证标准**:
- [ ] 测试用例覆盖所有场景
- [ ] 测试通过率100%
- [ ] 性能测试达标
- [ ] 安全测试通过
**上下文**:
- 现有测试框架: [使用的测试工具和框架]
- 测试数据: [测试数据准备和管理]
- 测试环境: [测试环境配置和要求]
**测试策略**:
- 单元测试: [具体的单元测试方法]
- 集成测试: [集成测试场景和方法]
- 端到端测试: [E2E测试流程和工具]
**自动化**:
- CI/CD集成配置
- 自动化测试执行
- 测试报告生成
```

### 完善任务模板
```markdown
## 完善和优化任务

### P1: [完善类型]
**描述**: [基于现有标准的完善描述]
**文件**: [相关文件路径]
**依赖**: [主要实现任务]
**验证标准**:
- [ ] 文档完整性和准确性
- [ ] 用户体验优化
- [ ] 性能优化效果
- [ ] 代码可维护性改进
**上下文**:
- 现有文档标准: [文档格式和要求]
- UX设计原则: [用户体验设计指导]
- 性能基准: [现有性能指标和目标]
**优化策略**:
- 代码重构和优化
- 用户界面改进
- 性能调优方法
**质量保证**:
- 文档审查流程
- 用户接受度测试
- 性能回归测试
```

## 依赖管理 - Context Engineering Enhanced

### 智能依赖分析
```yaml
技术依赖:
  - 代码依赖: 基于代码分析的真实依赖关系
  - 数据依赖: 数据模型和存储依赖
  - 接口依赖: API和服务接口依赖
  - 配置依赖: 环境和配置文件依赖

逻辑依赖:
  - 业务流程: 业务逻辑的执行顺序
  - 用户体验: 用户交互流程的依赖
  - 测试顺序: 测试执行的逻辑顺序
  - 部署顺序: 部署和发布的依赖关系

资源依赖:
  - 人员技能: 基于团队技能的任务分配
  - 时间窗口: 基于项目时间线的约束
  - 环境资源: 开发和测试环境的可用性
  - 外部依赖: 第三方服务和工具的依赖
```

### 并行执行策略
```yaml
并行组识别:
  - 独立模块: 可以并行开发的独立功能模块
  - 分层开发: 不同层次的并行开发策略
  - 团队分工: 基于团队结构的并行任务分配
  - 环境隔离: 利用不同环境进行并行开发

同步点管理:
  - 集成检查点: 定期的集成和同步检查
  - 代码合并: 代码合并的策略和时机
  - 测试同步: 集成测试的同步执行
  - 发布协调: 发布和部署的协调机制

冲突解决:
  - 代码冲突: 代码合并冲突的预防和解决
  - 资源冲突: 共享资源的访问协调
  - 时间冲突: 时间安排冲突的调解
  - 优先级冲突: 任务优先级的动态调整
```

## 进度跟踪 - Context Engineering Enhanced

### 智能进度监控
```yaml
自动化指标:
  - 代码提交频率和质量
  - 测试覆盖率和通过率
  - 构建成功率和部署频率
  - 代码审查完成率和质量

质量指标:
  - 代码质量分数和趋势
  - 技术债务积累和清理
  - 安全漏洞发现和修复
  - 性能指标和优化效果

团队效率:
  - 任务完成速度和质量
  - 团队协作效率指标
  - 知识分享和学习曲线
  - 问题解决时间和效率
```

### 风险预警系统
```yaml
早期预警:
  - 进度偏差检测和预警
  - 质量下降趋势识别
  - 资源瓶颈提前预警
  - 技术风险评估和提醒

自动化响应:
  - 自动化测试失败处理
  - 构建失败的自动重试
  - 性能回归的自动回滚
  - 安全问题的自动隔离

人工干预:
  - 复杂问题的升级机制
  - 专家支持的请求流程
  - 决策支持的数据提供
  - 应急响应的协调机制
```

## 验证和质量保证 - Context Engineering Enhanced

### 多层验证体系
```yaml
任务级验证:
  - 每个任务的完成标准验证
  - 代码质量和最佳实践检查
  - 功能正确性和性能验证
  - 文档完整性和准确性检查

模块级验证:
  - 模块集成和接口验证
  - 跨模块的数据流验证
  - 模块间的兼容性测试
  - 模块级的性能和安全测试

系统级验证:
  - 端到端功能验证
  - 系统性能和可靠性测试
  - 用户体验和接受度验证
  - 生产环境就绪性评估
```

### 持续改进机制
```yaml
反馈循环:
  - 开发过程中的实时反馈
  - 测试结果的快速反馈
  - 用户反馈的及时处理
  - 团队回顾和改进建议

学习和优化:
  - 最佳实践的总结和分享
  - 问题模式的识别和预防
  - 工具和流程的持续优化
  - 团队技能的提升和发展

知识管理:
  - 项目知识的文档化
  - 经验教训的记录和分享
  - 技术决策的追溯和评估
  - 团队知识库的建设和维护
```

---

## 示例任务列表

### 基于Context Engineering的智能任务生成示例

```markdown
# 任务执行计划

## 阶段1: 环境准备 (并行执行)
**S1**: 开发环境配置 [2小时] → 验证: 环境就绪检查
**S2**: 依赖管理设置 [1小时] → 验证: 依赖完整性验证
**S3**: 开发工具配置 [1小时] → 验证: 工具链集成测试

## 阶段2: 核心开发 (部分并行)
**C1**: 数据模型实现 [4小时] ← S1,S2 → 验证: 模型验证测试
**C2**: 业务逻辑核心 [6小时] ← C1 → 验证: 单元测试 + 业务逻辑验证
**C3**: API接口实现 [4小时] ← C1,C2 → 验证: API测试 + 接口规范验证
**C4**: 用户界面开发 [5小时] ← C3 (并行于C2) → 验证: UI测试 + 用户体验验证

## 阶段3: 集成验证 (顺序执行)
**I1**: 系统集成测试 [3小时] ← C2,C3,C4 → 验证: 集成测试套件
**I2**: 性能优化调试 [2小时] ← I1 → 验证: 性能基准测试
**I3**: 安全验证测试 [2小时] ← I1 → 验证: 安全扫描 + 渗透测试

## 阶段4: 完善交付 (部分并行)
**P1**: 文档编写完善 [3小时] ← I1 (并行于I2,I3) → 验证: 文档审查
**P2**: 用户接受度测试 [2小时] ← I2,I3 → 验证: UAT测试
**P3**: 部署准备配置 [2小时] ← P2 → 验证: 部署验证

**总估时**: 37小时 | **关键路径**: S1→C1→C2→C3→I1→I2→P2→P3 (26小时)
**并行优化**: 可节省11小时 | **风险缓冲**: 建议增加20%时间缓冲
```

---

*此任务模板使用Context Engineering深度增强，提供智能任务生成、依赖优化和质量保证，确保高效和高质量的功能实施。*