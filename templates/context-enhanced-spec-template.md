# 功能规范：[功能名称] - Context Engineering Enhanced

**功能分支**: `[###-功能名称]`  
**创建时间**: [日期]  
**状态**: 草稿  
**输入**: 用户描述："$ARGUMENTS"
**上下文工程级别**: [轻量级/标准/深度] - 根据功能复杂度自动确定

## 执行流程（Context Engineering Enhanced）
```
1. 上下文预分析阶段
   → 评估功能复杂度：简单/中等/复杂/创新
   → 确定上下文工程级别：轻量级/标准/深度
   → 初始化上下文收集器

2. 深度需求解析
   → 从用户描述中提取关键概念
   → 识别：参与者、操作、数据、约束、集成点
   → 自动搜索相似功能模式
   → 标记潜在技术依赖

3. 智能澄清识别
   → 基于代码库上下文分析模糊点
   → 对比现有实现模式
   → 标记为 [需要澄清：具体问题 + 建议方向]
   → 生成澄清问题优先级

4. 上下文丰富的用户场景构建
   → 结合现有用户流程模式
   → 参考类似功能的测试用例
   → 生成边界条件和异常场景
   → 验证与现有功能的一致性

5. 验证驱动的需求生成
   → 每个需求必须可测试且可验证
   → 关联到具体的验证方法
   → 标记需要集成测试的需求
   → 生成验证检查清单

6. 技术上下文预评估
   → 识别关键技术依赖
   → 评估与现有架构的兼容性
   → 标记潜在的技术风险
   → 生成技术研究清单

7. 增强审查检查清单
   → 运行标准检查清单
   → 执行上下文一致性检查
   → 验证与代码库模式的对齐
   → 评估实施可行性

8. 返回：成功（规范准备好进行深度规划）
```

---

## ⚡ 快速指南 - Context Engineering Enhanced
- ✅ 专注于用户需要什么和为什么（保持Spec Kit原则）
- ✅ 提供丰富的上下文信息支持后续实施
- ✅ 建立与现有代码库的明确连接
- ❌ 避免如何实施（无技术栈、API、代码结构）
- 👥 为业务利益相关者而非开发人员编写
- 🧠 为AI代理提供充分的上下文进行自我验证

### 章节要求
- **必需章节**：每个功能都必须完成
- **可选章节**：仅在与功能相关时包含
- **上下文章节**：根据复杂度级别动态包含
- 当章节不适用时，完全删除它（不要留作"N/A"）

### Context Engineering集成指南
从用户提示创建此规范时：
1. **智能歧义标记**：基于代码库上下文分析，使用 [需要澄清：具体问题 + 代码库参考]
2. **上下文驱动推理**：利用现有实现模式进行合理推断
3. **验证优先思维**：每个需求都关联到具体的验证方法
4. **模式识别**：自动识别与现有功能的相似性和差异
5. **常见未充分指定的领域**：
   - 用户类型和权限（参考现有权限模型）
   - 数据保留/删除策略（对比现有数据处理）
   - 性能目标和规模（基于现有性能基准）
   - 错误处理行为（遵循现有错误处理模式）
   - 集成需求（分析现有集成点）

---

## 📋 用户场景和测试 - Context Enhanced

### 主要用户故事
**作为** [用户类型]，**我想要** [功能]，**以便** [价值]

**上下文连接**: 类似于现有功能 [参考功能名称]，但有以下差异：[具体差异]

### 验收场景
1. **场景**: [描述]
   - **给定**: [前置条件]
   - **当**: [操作]
   - **那么**: [预期结果]
   - **验证方法**: [具体的测试方法]
   - **现有模式参考**: [相似功能的测试模式]

### 边界情况
- [基于现有代码库分析的边界情况]
- [参考现有功能的边界处理方式]

---

## 📋 需求 - Context Engineering Enhanced

### 业务背景和价值主张
[功能的业务价值和用户影响]

**与现有功能的关系**: [描述与现有功能的集成点和依赖关系]

### 功能需求
每个需求都包含：
- **需求描述**: [具体需求]
- **验证标准**: [如何验证此需求]
- **现有模式**: [参考的现有实现模式]
- **优先级**: [高/中/低]

1. **[需求1]**
   - 验证标准: [具体的验证方法]
   - 现有模式: [参考src/existing_feature.py的实现]
   - 优先级: 高

### 非功能性需求
- **性能**: [基于现有性能基准的具体目标]
- **安全**: [遵循现有安全模式]
- **可用性**: [符合现有UI/UX模式]
- **兼容性**: [与现有系统的兼容性要求]

---

## 🔍 上下文信息 - Context Engineering Core

### 代码库连接点
```yaml
相似功能参考:
  - file: src/existing_feature.py
    similarity: [相似度和差异点]
    patterns_to_follow: [需要遵循的模式]
    
  - file: tests/test_existing.py
    why: [测试模式参考]
    
集成点:
  - module: [需要集成的模块]
    interface: [集成接口]
    considerations: [集成注意事项]
```

### 技术上下文预评估
```yaml
潜在依赖:
  - library: [可能需要的库]
    reason: [使用原因]
    existing_usage: [现有使用情况]
    
架构影响:
  - component: [受影响的组件]
    impact: [影响程度和类型]
    mitigation: [缓解策略]
```

### 验证策略
```yaml
验证层级:
  - unit_tests: [单元测试策略]
  - integration_tests: [集成测试策略]
  - e2e_tests: [端到端测试策略]
  
验证工具:
  - static_analysis: [静态分析工具]
  - runtime_validation: [运行时验证]
  - performance_testing: [性能测试方法]
```

---

## 🎯 实施准备清单

### 规范完整性
- [ ] 所有用户场景都有明确的验收标准
- [ ] 每个功能需求都有验证方法
- [ ] 与现有功能的集成点已识别
- [ ] 技术风险已评估
- [ ] 验证策略已定义

### 上下文充分性
- [ ] 相似功能模式已识别和参考
- [ ] 代码库集成点已分析
- [ ] 潜在技术依赖已评估
- [ ] 验证工具和方法已确定
- [ ] 实施复杂度已评估

### 澄清状态
- [ ] 所有 [需要澄清] 项目都有具体的问题描述
- [ ] 澄清问题都有建议的解决方向
- [ ] 澄清优先级已确定
- [ ] 可以基于现有模式推断的项目已标记

---

## 📊 复杂度评估

**功能复杂度**: [简单/中等/复杂/创新]
**上下文工程级别**: [轻量级/标准/深度]
**预估实施时间**: [基于相似功能的历史数据]
**风险级别**: [低/中/高]
**需要专家审查**: [是/否]

**复杂度因子**:
- 新技术使用: [是/否]
- 多系统集成: [是/否]
- 性能关键: [是/否]
- 安全敏感: [是/否]
- 用户体验创新: [是/否]

---

*此规范使用Context Engineering增强，为后续的深度规划和实施提供充分的上下文支持。*