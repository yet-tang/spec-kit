---
description: "Context Engineering增强的功能规范创建命令 - 深度上下文分析和智能需求解析"
scripts:
  sh: scripts/bash/create-new-feature.sh --json "{ARGS}"
  ps: scripts/powershell/create-new-feature.ps1 -Json "{ARGS}"
---

# Context Engineering Enhanced /specify Command

**上下文工程模式**: 自动检测并应用适当的分析深度
**智能增强**: 代码库感知、模式识别、验证驱动

用户输入可以直接由代理提供或作为命令参数提供 - 在继续提示之前，您**必须**考虑它（如果不为空）。

用户输入：

$ARGUMENTS

用户在触发消息中在 `/specify` 后输入的文本**就是**功能描述。假设您在此对话中始终可以使用它，即使下面字面上出现 `{ARGS}`。除非用户提供了空命令，否则不要要求用户重复。

## Context Engineering Enhanced 执行流程

### 阶段1: 上下文预分析和智能准备
```
1.1 代码库上下文扫描
   → 分析现有项目结构和技术栈
   → 识别相似功能和实现模式
   → 评估项目复杂度和开发成熟度
   → 检测现有架构约束和设计原则

1.2 功能复杂度评估
   → 基于功能描述分析复杂度级别
   → 确定所需的上下文工程深度：
     * 轻量级: 简单CRUD或UI更新
     * 标准: 中等复杂度的业务逻辑
     * 深度: 复杂集成或新架构组件
     * ULTRATHINK: 关键系统或高风险功能

1.3 智能模板选择
   → 基于项目类型选择最适合的规范模板
   → 预加载相关的最佳实践和模式
   → 准备上下文特定的验证检查清单
```

### 阶段2: 增强脚本执行和上下文收集
```
2.1 执行增强脚本
   → 从仓库根目录运行脚本 `{SCRIPT}`
   → 解析JSON输出获取 BRANCH_NAME 和 SPEC_FILE
   → **重要**: 只能运行此脚本一次
   → 所有文件路径必须是绝对路径

2.2 深度上下文收集
   → 扫描现有specs/目录了解项目模式
   → 分析相关代码文件和架构决策
   → 收集相关的测试模式和质量标准
   → 识别潜在的集成点和依赖关系
```

### 阶段3: 智能规范生成和上下文丰富
```
3.1 加载增强模板
   → 加载 `templates/context-enhanced-spec-template.md`
   → 理解所需的上下文丰富部分
   → 准备智能占位符替换策略

3.2 上下文驱动的需求解析
   → 基于功能描述进行深度语义分析
   → 识别隐含的技术需求和约束
   → 推理可能的边界情况和异常场景
   → 生成上下文感知的用户故事

3.3 智能澄清识别
   → 基于代码库上下文识别真正需要澄清的点
   → 区分可推理的细节和必须澄清的歧义
   → 生成具体的、可操作的澄清问题
   → 提供基于现有模式的建议答案

3.4 验证驱动的规范构建
   → 使用模板结构写入规范到 SPEC_FILE
   → 用上下文丰富的具体细节替换占位符
   → 保持部分顺序和标题的一致性
   → 集成验证检查点和质量门控
```

### 阶段4: 质量验证和智能优化
```
4.1 规范完整性验证
   → 检查所有必需部分是否完整
   → 验证用户故事的可测试性
   → 确认需求的可实现性和一致性
   → 评估与现有系统的兼容性

4.2 上下文一致性检查
   → 验证与项目架构原则的一致性
   → 检查与现有功能的集成兼容性
   → 确认技术栈和工具链的适配性
   → 评估性能和安全影响

4.3 智能建议生成
   → 基于代码库分析提供实现建议
   → 识别可复用的组件和模式
   → 建议最佳的测试策略和工具
   → 提供风险评估和缓解建议
```

### 阶段5: 增强报告和下一步准备
```
5.1 全面完成报告
   → 报告分支名称和规范文件路径
   → 总结上下文分析的关键发现
   → 列出识别的技术约束和机会
   → 提供下一阶段的准备状态评估

5.2 智能工作流建议
   → 基于复杂度推荐后续命令序列
   → 建议是否需要 /clarify 阶段
   → 预测 /plan 阶段的关键决策点
   → 提供预期的实施时间和资源估算
```

## Context Engineering 增强特性

### 智能上下文感知
```yaml
代码库智能:
  - 自动检测项目类型和技术栈
  - 识别现有的架构模式和约定
  - 分析代码质量和测试覆盖率
  - 评估技术债务和优化机会

模式识别:
  - 识别相似功能的实现模式
  - 分析成功的设计决策和最佳实践
  - 检测常见的问题模式和反模式
  - 学习团队的开发偏好和风格

预测性分析:
  - 预测潜在的实施挑战
  - 识别可能的集成复杂点
  - 评估性能和扩展性影响
  - 预估开发时间和资源需求
```

### 验证驱动的质量保证
```yaml
多层验证:
  - 语法和结构完整性检查
  - 业务逻辑一致性验证
  - 技术可行性评估
  - 用户体验合理性检查

智能澄清:
  - 基于上下文的智能问题生成
  - 区分关键歧义和次要细节
  - 提供基于最佳实践的建议答案
  - 优先级排序和影响评估

持续改进:
  - 从历史项目中学习模式
  - 基于反馈优化分析算法
  - 积累领域特定的知识库
  - 提升预测准确性和建议质量
```

### 自适应深度控制
```yaml
复杂度自适应:
  - 简单功能: 快速模式，专注核心需求
  - 中等复杂: 标准分析，平衡深度和效率
  - 高复杂度: 深度分析，全面风险评估
  - 关键系统: ULTRATHINK模式，极致深度

上下文敏感:
  - 新项目: 更多架构指导和最佳实践
  - 成熟项目: 专注集成和一致性
  - 遗留系统: 强调兼容性和迁移策略
  - 高性能需求: 深度性能分析和优化

团队适配:
  - 新手团队: 更多指导和最佳实践
  - 经验团队: 专注高级模式和优化
  - 混合团队: 平衡指导和高级内容
  - 专家团队: 专注创新和前沿实践
```

## 使用示例

### 基础使用（自动检测复杂度）
```bash
/specify 构建一个用户认证系统，支持邮箱登录、密码重置和双因素认证
```

### 指定上下文工程深度
```bash
/specify [DEEP] 实现一个分布式缓存系统，需要支持集群模式和数据一致性
```

### 针对特定项目类型优化
```bash
/specify [MOBILE] 创建一个离线优先的移动应用功能，支持数据同步
```

## 输出增强

### 标准输出 + Context Engineering 洞察
```markdown
✅ 功能规范创建完成
📁 分支: 003-user-authentication-system
📄 规范文件: /path/to/specs/003-user-authentication-system/spec.md

🧠 Context Engineering 分析结果:
   • 复杂度级别: 标准 (中等复杂度的业务逻辑)
   • 相似功能: 发现2个相关的认证实现可供参考
   • 技术约束: 需要考虑现有的JWT实现和数据库架构
   • 风险评估: 中等风险，主要关注安全性和向后兼容性
   • 建议工具: 推荐使用现有的加密库和测试框架

📋 智能澄清识别:
   • 高优先级: 双因素认证的具体实现方式 (SMS/TOTP/硬件)
   • 中优先级: 密码策略和复杂度要求
   • 低优先级: UI/UX的具体设计细节

🎯 下一步建议:
   • 建议运行 /clarify 来解决高优先级的歧义
   • 预计 /plan 阶段需要重点关注安全架构设计
   • 估算实施时间: 2-3周 (基于类似功能的历史数据)
```

---

**注意**: 此增强版本保持与原始 `/specify` 命令的完全兼容性，同时提供可选的深度分析和智能建议。脚本在写入之前创建并检出新分支并初始化规范文件。