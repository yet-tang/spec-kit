# 规范驱动开发：AI时代的软件开发新范式

## 概述

规范驱动开发（Spec-Driven Development，SDD）是传统开发流程的一次根本性颠覆。在传统开发中，规范往往是事后文档，而在SDD中，规范成为了代码生成的直接驱动力。这种转变消除了规范与实现之间的鸿沟，让规范成为软件开发的核心工件。

### 传统开发的困境

在传统软件开发中，我们面临着一个根本性的问题：规范与实现之间存在着不可避免的差距。无论我们多么努力地维护文档，代码总是会偏离最初的设计意图。这种偏离不是因为开发者的疏忽，而是因为实现过程中不可避免的发现和调整。

### AI驱动的转变

AI的出现改变了这一切。现在，我们可以让规范直接生成代码，而不是仅仅指导代码编写。这种转变让规范成为了主要工件，代码成为了规范的表达形式。

## SDD工作流程

### 1. 从想法到产品需求文档（PRD）

SDD的起点是一个简单的想法，通过与AI的迭代对话，这个想法逐步演化为一个全面的产品需求文档。这个过程不是一次性的，而是通过多轮对话不断细化和完善的。

**示例对话流程：**
```
用户：我想构建一个聊天功能
AI：让我们明确一下需求...
[多轮对话后]
结果：完整的聊天功能PRD，包含用户故事、技术要求、验收标准
```

### 2. 研究与技术调研

在规范确定后，研究代理会自动收集相关的技术信息、最佳实践和实现方案。这确保了规范基于最新的技术知识和行业标准。

### 3. 实施计划生成

基于完善的规范，系统会生成详细的实施计划，包括：
- 技术架构设计
- 开发阶段划分
- 任务分解
- 依赖关系管理

### 4. 任务推导

实施计划会被进一步分解为具体的、可执行的任务。每个任务都有明确的输入、输出和验收标准。

### 5. 并行化执行

任务可以并行执行，提高开发效率。系统会自动识别任务之间的依赖关系，确保执行顺序的正确性。

## SDD与传统开发的对比

### 传统聊天功能开发
```
1. 写一些代码
2. 测试是否工作
3. 修复问题
4. 重复上述过程
```

### SDD聊天功能开发
```
/specify "实时聊天功能，支持多用户、消息历史、在线状态"
/plan     # 生成技术实施计划
/tasks    # 分解为具体任务
/implement # 执行实施
```

## 为什么选择SDD？

### 1. AI能力的成熟

现代AI已经具备了理解复杂需求、生成高质量代码的能力。SDD充分利用了这些能力。

### 2. 软件复杂性的增加

现代软件系统越来越复杂，传统的开发方法难以应对。SDD通过结构化的方法来管理这种复杂性。

### 3. 变化速度的加快

市场需求变化越来越快，SDD的快速迭代能力让我们能够更好地适应这种变化。

## SDD的核心原则

### 1. 规范作为通用语言

规范成为了所有利益相关者（产品经理、开发者、测试人员）之间的通用语言。每个人都能理解和贡献到规范中。

### 2. 可执行的规范

规范不再是静态文档，而是可以直接生成代码的活文档。这确保了规范与实现的一致性。

### 3. 迭代式细化

规范通过多轮迭代不断完善，每次迭代都会带来更深入的理解和更好的实现。

### 4. AI依赖性

SDD充分依赖AI的能力，让AI成为开发过程中的核心参与者，而不仅仅是工具。

## 实施方法

### 核心命令

SDD提供了一系列命令来支持整个开发流程：

- `/specify` - 创建和完善规范
- `/plan` - 生成技术实施计划
- `/tasks` - 分解任务
- `/implement` - 执行实施

### 模板驱动的质量保证

SDD使用模板来指导LLM生成高质量的规范。这些模板包含了最佳实践和质量检查点。

#### 1. 强制明确性

模板强制LLM明确表达不确定性：

```markdown
### 不确定性标记
- [ ] 需要澄清：用户认证方法
- [ ] 假设：使用PostgreSQL数据库
- [ ] 风险：第三方API可用性
```

#### 2. 结构化检查清单

模板包含详细的检查清单，确保规范的完整性：

```markdown
### 功能完整性检查
- [ ] 所有用户故事都有验收标准
- [ ] 错误处理场景已定义
- [ ] 性能要求已明确
- [ ] 安全考虑已包含
```

#### 3. 系统化自我审查

检查清单强制LLM系统性地审查其输出，捕获可能遗漏的问题。这就像给LLM提供了一个质量保证框架。

#### 4. 通过门控实现架构合规

实施计划模板通过阶段门控来强制执行架构原则：

```markdown
### 阶段-1：实施前门控
#### 简单性门控（第七条）
- [ ] 使用≤3个项目？
- [ ] 没有过度设计？
#### 反抽象门控（第八条）
- [ ] 直接使用框架？
- [ ] 单一模型表示？
```

这些门控通过让LLM明确证明任何复杂性来防止过度工程化。如果门控失败，LLM必须在"复杂性跟踪"部分记录原因，为架构决策创建问责制。

#### 5. 分层细节管理

模板强制执行适当的信息架构：

```text
**重要**：此实施计划应保持高层次和可读性。
任何代码示例、详细算法或广泛的技术规范
必须放在相应的`implementation-details/`文件中
```

这防止了规范变成不可读的代码堆的常见问题。LLM学会保持适当的细节级别，将复杂性提取到单独的文件中，同时保持主文档的可导航性。

#### 6. 测试优先思维

实施模板强制执行测试优先开发：

```text
### 文件创建顺序
1. 创建带有API规范的`contracts/`
2. 按顺序创建测试文件：合约 → 集成 → 端到端 → 单元
3. 创建源文件以使测试通过
```

这种排序约束确保LLM在实施之前考虑可测试性和合约，从而产生更健壮和可验证的规范。

#### 7. 防止投机性功能

模板明确阻止投机：

```text
- [ ] 没有投机性或"可能需要"的功能
- [ ] 所有阶段都有明确的先决条件和交付物
```

这阻止了LLM添加使实施复杂化的"最好有"功能。每个功能都必须追溯到具有明确验收标准的具体用户故事。

### 复合效应

这些约束共同作用，产生以下特点的规范：

- **完整性**：检查清单确保没有遗漏
- **明确性**：强制澄清标记突出不确定性
- **可测试性**：测试优先思维融入过程
- **可维护性**：适当的抽象级别和信息层次
- **可实施性**：具有具体交付物的明确阶段

模板将LLM从创意作家转变为有纪律的规范工程师，将其能力引导到产生一致的高质量、可执行的规范，真正驱动开发。

## 架构基础：强制执行架构纪律

SDD的核心是一部宪法——一套管理规范如何成为代码的不可变原则。宪法（`memory/constitution.md`）作为系统的架构DNA，确保每个生成的实施都保持一致性、简单性和质量。

### 开发的九条原则

宪法定义了塑造开发过程各个方面的九条原则：

#### 第一条：库优先原则

每个功能都必须从独立库开始——没有例外。这从一开始就强制模块化设计：

```text
Specify中的每个功能都必须从独立库开始存在。
任何功能都不得直接在应用程序代码中实施，
必须首先抽象为可重用的库组件。
```

这个原则确保规范生成模块化、可重用的代码，而不是单体应用程序。当LLM生成实施计划时，它必须将功能构建为具有清晰边界和最小依赖的库。

#### 第二条：CLI接口要求

每个库都必须通过命令行接口公开其功能：

```text
所有CLI接口必须：
- 接受文本作为输入（通过stdin、参数或文件）
- 产生文本作为输出（通过stdout）
- 支持结构化数据交换的JSON格式
```

这强制执行可观察性和可测试性。LLM不能将功能隐藏在不透明的类中——一切都必须通过基于文本的接口可访问和可验证。

#### 第三条：测试优先要求

最具变革性的条款——代码之前必须有测试：

```text
这是不可协商的：所有实施必须遵循严格的测试驱动开发。
在以下条件满足之前，不得编写实施代码：
1. 编写单元测试
2. 测试经过验证并获得用户批准
3. 确认测试失败（红色阶段）
```

这完全颠覆了传统的AI代码生成。LLM不是生成代码并希望它工作，而是必须首先生成定义行为的全面测试，获得批准，然后才生成实施。

#### 第七条和第八条：简单性和反抽象

这些配对的条款对抗过度工程化：

```text
第7.3节：最小项目结构
- 初始实施最多3个项目
- 额外项目需要文档化的理由

第8.1节：框架信任
- 直接使用框架功能而不是包装它们
```

当LLM可能自然地创建复杂的抽象时，这些条款强制它证明每一层复杂性的合理性。实施计划模板的"阶段-1门控"直接强制执行这些原则。

#### 第九条：集成优先测试

优先考虑现实世界测试而不是孤立的单元测试：

```text
测试必须使用现实环境：
- 优先使用真实数据库而不是模拟
- 使用实际服务实例而不是存根
- 实施前必须进行合约测试
```

这确保生成的代码在实践中工作，而不仅仅是理论上。

### 通过模板强制执行宪法

实施计划模板通过具体检查点来操作化这些条款：

```markdown
### 阶段-1：实施前门控
#### 简单性门控（第七条）
- [ ] 使用≤3个项目？
- [ ] 没有过度设计？

#### 反抽象门控（第八条）
- [ ] 直接使用框架？
- [ ] 单一模型表示？

#### 集成优先门控（第九条）
- [ ] 合约已定义？
- [ ] 合约测试已编写？
```

这些门控作为架构原则的编译时检查。LLM不能继续进行，除非通过门控或在"复杂性跟踪"部分记录合理的例外。

### 不可变原则的力量

宪法的力量在于其不可变性。虽然实施细节可以演化，但核心原则保持不变。这提供了：

1. **跨时间的一致性**：今天生成的代码遵循与明年生成的代码相同的原则
2. **跨LLM的一致性**：不同的AI模型产生架构兼容的代码
3. **架构完整性**：每个功能都加强而不是破坏系统设计
4. **质量保证**：测试优先、库优先和简单性原则确保可维护的代码

### 宪法演化

虽然原则是不可变的，但它们的应用可以演化：

```text
第4.2节：修正过程
对此宪法的修改需要：
- 明确记录变更理由
- 项目维护者审查和批准
- 向后兼容性评估
```

这允许方法论学习和改进，同时保持稳定性。宪法显示其自身的演化，带有日期的修正案，展示了如何基于现实世界经验来完善原则。

### 超越规则：开发哲学

宪法不仅仅是规则手册——它是塑造LLM如何思考代码生成的哲学：

- **可观察性胜过不透明性**：一切都必须通过CLI接口可检查
- **简单性胜过聪明性**：从简单开始，只有在证明必要时才增加复杂性
- **集成胜过隔离**：在真实环境中测试，而不是人工环境
- **模块化胜过单体**：每个功能都是具有清晰边界的库

通过将这些原则嵌入到规范和规划过程中，SDD确保生成的代码不仅仅是功能性的——它是可维护的、可测试的和架构健全的。宪法将AI从代码生成器转变为尊重和加强系统设计原则的架构伙伴。

## 变革的意义

这不是要取代开发者或自动化创造力。这是通过自动化机械翻译来放大人类能力。这是创建一个紧密的反馈循环，其中规范、研究和代码一起演化，每次迭代都带来更深入的理解和意图与实施之间更好的对齐。

软件开发需要更好的工具来维护意图与实施之间的对齐。SDD通过生成代码而不是仅仅指导代码的可执行规范，提供了实现这种对齐的方法论。